<Layer Type = "ActorFrame" InitCommand = "%function() -- By XeroOl
	
	-- config
	local MAX_PN = 2
	
	local old_xero = _G.xero
	
	-- global for xml setup and environment for Lua
	local xero = setmetatable({}, {
		__call = function(self, func)
			setfenv(func, self)
			return func
		end,
		__index = _G
	})
	
	do -- default global vars
		
		xero.scx = SCREEN_CENTER_X
		xero.scy = SCREEN_CENTER_Y
		xero.sw = SCREEN_WIDTH
		xero.sh = SCREEN_HEIGHT
		xero.srat = SCREEN_WIDTH / SCREEN_HEIGHT
		
		xero.MAX_PN = MAX_PN
		
	end
	
	do -- actor helpers
		
		-- table for holding named actors
		xero.actors = {}
		
		-- Use it to insert into xero.actors at init-time
		-- NameCommand = &quot;xero.name.<actor_name>&quot;
		xero.name = setmetatable({},{__index = function(self, name)
			return function(self)
				xero.actors[name] = self
			end
		end})
		
		-- aft function
		function xero.aft(self)
			self:SetWidth(DISPLAY:GetDisplayWidth())
			self:SetHeight(DISPLAY:GetDisplayHeight())
			self:EnableDepthBuffer(false)
			self:EnableAlphaBuffer(false)
			self:EnableFloat(false)
			self:EnablePreserveTexture(true)
			self:Create()
		end
		
		-- aft sprite function
		function xero.sprite(self)
			self:basezoomx((SCREEN_WIDTH/DISPLAY:GetDisplayWidth()))
			self:basezoomy(-1*(SCREEN_HEIGHT/DISPLAY:GetDisplayHeight()))
			self:x(SCREEN_CENTER_X)
			self:y(SCREEN_CENTER_Y)
		end
		
		-- full screen actor function
		function xero.image(self)
			self:zoomto(SCREEN_WIDTH, SCREEN_HEIGHT)
			self:x(SCREEN_CENTER_X)
			self:y(SCREEN_CENTER_Y)
		end
	end
	
	local function throw(exception, level)
		level = level or 5
		local _, err = pcall(error, exception, level)
		SCREENMAN:SystemMessage(err)
	end
	
	-- holds the timing mode
	local valid_timing_modes = {['len'] = true, ['end'] = true}
	local timing_mode = 'len'
	
	
	-- setter for timing mode
	function xero.set_timing_mode(mode)
		if not valid_timing_modes[mode] then
			throw('invalid timing mode \'' .. mode .. '\'', 4)
		else
			timing_mode = mode
		end
	end
	
	-- verifier for ease and ease_to
	local function check_valid_ease(input, function_name)
		if type(input) ~= 'table' then
			throw('\'{\' expected near \''.. function_name ..'\'')
		elseif type(input[1]) ~= 'number' then
			throw('invalid start beat \'' .. tostring(input[1]) .. '\'')
		elseif type(input[2]) ~= 'number' then
			throw('invalid ' .. timing_mode .. ' \'' .. tostring(input[2]) .. '\'')
		elseif type(input[3]) ~= 'function' or type(input[3](0) or nil) ~= 'number' then
			throw('invalid ease function \'' .. tostring(input[3]) .. '\'')
		elseif input.mode ~= nil and not valid_timing_modes[input.mode] then
			throw('invalid timing mode \'' .. tostring(input.mode) .. '\'')
		elseif input.pn ~= nil and (input.pn < 0 or input.pn > MAX_PN or input.pn ~= math.floor(input.pn)) then
			throw('invalid player number \'' .. tostring(input.pn) .. '\'')
		else
			local val = 5
			while input[val] or input[val - 1] do
				if type(input[val - 1]) ~= 'number' then
					throw('invalid percentage \'' .. tostring(input[val - 1]) .. '\' for mod \'' .. tostring(input[val]) .. '\'')
					return
				elseif input[val] == nil then
					throw('invalid mod \'nil\'')
				end
				val = val + 2
			end
			return true
		end
	end
	
	-- verifier for func
	local function check_valid_func(input)
		if type(input) ~= 'table' then
			throw('\'{\' expected near \'func\'')
		elseif type(input[1]) ~= 'number' then
			throw('invalid start beat \'' .. tostring(input[1]) .. '\'')
		elseif input[3] then
			if type(input[2]) ~= 'number' then
				throw('invalid '.. timing_mode .. ' \'' .. tostring(input[2]) .. '\'')
			elseif type(input[3]) ~= 'function' then
				throw('invalid function \'' .. tostring(input[3]) .. '\'')
			elseif input.mode ~= nil and not valid_timing_modes[input.mode] then
				throw('invalid timing mode \'' .. tostring(input.mode) .. '\'')
			else
				return true
			end
		elseif type(input[2]) ~= 'function' then
			throw('invalid function \'' .. tostring(input[2]) .. '\'')
		else
			return true
		end
	end
	
	-- converts an ease entry to len mode
	local function timing_mode_adjust(input)
		local mode = input.mode or timing_mode
		
		-- if necessary, adjust to internal 'len' based format
		if mode == 'end' and type(input[2]) == 'number' then
			local adjusted_len = input[2] - input[1]
			if adjusted_len >= 0 then
				input[2] = adjusted_len
			end
		end
		
	end
	
	-- exceptions for how to apply mods
	local ease_vars = {}
	
	-- add new exceptions to ease_vars
	function xero.ease_var(mod, value)
		value = value or true
		ease_vars[mod] = value
		return xero.ease_var
	end
	
	
	-- ease table
	local mod_ease = {}
	local mod_ease_active = {}
	local mod_ease_length = 0
	local mod_ease_next = 1
	
	local function insert_ease(input)
		timing_mode_adjust(input)
		mod_ease_length = mod_ease_length + 1
		mod_ease[mod_ease_length] = input
	end
	
	-- ease table insert
	function xero.ease(input)
		if check_valid_ease(input, 'ease') then
			insert_ease(input)
		end
		return xero.ease
	end
	
	-- ease table insert, for absolute position eases
	function xero.ease_to(input)
		if check_valid_ease(input, 'ease_to') then
			input.absolute = true
			insert_ease(input)
		end
		return xero.ease_to
	end
	
	-- func table
	local mod_func = {}
	local mod_func_active = {}
	local mod_func_length = 0
	local mod_func_next = 1
	
	-- func table insert
	function xero.func(input)
		if check_valid_func(input) then
			timing_mode_adjust(input)
			if type(input[2]) == 'function' then
				input[2], input[3] = nil, input[2]
			end
			mod_func_length = mod_func_length + 1
			mod_func[mod_func_length] = input
		end
		return xero.func
	end
	
	-- prepare mods
	function xero.ready(self)
		
		-- apply default mods
		xero.ease_var('xmod', function(percent) return '*9e9 ' .. percent .. 'x' end)
		xero.ease_var('cmod', function(percent) return '*9e9 c' .. percent end)
		
		local function hide(actor)
			if actor then
				actor:hidden(1)
			end
		end
		
		local top = SCREENMAN:GetTopScreen()
		
		-- create player table
		xero.plr = {}
		
		for pn = 1, MAX_PN do
			xero.plr[pn] = top:GetChild('PlayerP' .. pn)
		end
		
		-- plr 0 guaranted to exist for notedata
		xero.plr[0] = xero.plr[1] or xero.plr[2]
		
		-- hide extra stuff
		hide(top:GetChild('Overlay'))
		hide(top:GetChild('Underlay'))
		for pn = 1, 2 do
			hide(top:GetChild('ScoreP' .. pn))
			hide(top:GetChild('LifeP' .. pn))
		end
		
		-- load mods
		xero.actors.mods:playcommand'Mod'
		
		-- sort tables
		xero.stable_sort(mod_ease, function(a, b)
			return a[1] < b[1]
		end)
		xero.stable_sort(mod_func, function(a, b)
			return a[1] < b[1]
		end)
		
		-- start the update loop
		self:luaeffect('Update')
	end
	
	-- placeholder 0 for perfuncs
	local nil_as_0_metatable = {
		__index = function(self, key)
			return 0
		end
	}
	
	-- tables for base values (for accessing and iterating, respectively)
	local mod_base = {data = {}}
	
	-- table for temp values
	local mod_values = {}
	
	-- set up base values
	for pn = 0, MAX_PN do
		local data = setmetatable({}, nil_as_0_metatable)
		mod_base.data[pn] = data
		mod_base[pn] = setmetatable({}, {
			__index = data,
			__newindex = function(self, key, value)
				if value == 0 then
					data[key] = nil
				else
					data[key] = value
				end
			end
		})
	end
	
	-- progress vars
	local beat = 0
	local cur_time = 0
	local old_time = 0
	
	-- adjust an entry that has absolute positions to use relative positions
	local function adjust_absolute_ease(entry)
		
		local pn = entry.pn or 0
		
		local val = 5
		while entry[val] do
			entry[val - 1] = entry[val - 1] - mod_base[pn][entry[val]]
			val = val + 2
		end
		
	end
	
	-- update mod_base
	local function start_ease(entry)
		
		-- if in absolute coordinates
		if entry.absolute then
			adjust_absolute_ease(entry)
		end
		
		local pn = entry.pn or 0
		local target = entry[3](1)
		
		local val = 5
		while entry[val] do
			mod_base[pn][entry[val]] = mod_base[pn][entry[val]] + target * entry[val - 1]
			mod_values[pn][entry[val]] = mod_values[pn][entry[val]] + target * entry[val - 1]
			val = val + 2
		end
		
		entry.target_value = target
		
	end
	
	-- apply an ease to mod_values
	local function apply_ease(entry)
		
		local pn = entry.pn or 0
		local ease
		
		-- if not yet done
		if beat < entry[1] + entry[2] then 
			ease = entry[3]((beat - entry[1]) / entry[2])
		
		-- cap to end value
		else
			ease = entry.target_value
		end
		
		local val = 5
		while entry[val] do
			mod_values[pn][entry[val]] = mod_values[pn][entry[val]] + (ease - entry.target_value) * entry[val - 1]
			val = val + 2
		end
		
	end
	
	-- update command
	function xero.update(self)
		cur_time = self:GetSecsIntoEffect()
		if cur_time ~= old_time then
			
			old_time = cur_time
			beat = GAMESTATE:GetSongBeat()
			
			-- initialize mod_values to mod_base
			mod_values = {}
			for pn = 0, MAX_PN do
				mod_values[pn] = setmetatable({}, nil_as_0_metatable)
				for mod, percent in pairs(mod_base.data[pn]) do
					mod_values[pn][mod] = percent
				end
			end
			
			-- mod eases
			while mod_ease_next <= mod_ease_length do
				local entry = mod_ease[mod_ease_next]
				if beat < entry[1] then
					break
				end
				start_ease(entry)
				if beat < entry[1] + entry[2] then
					mod_ease_active[mod_ease_next] = entry
				end
				mod_ease[mod_ease_next] = nil
				mod_ease_next = mod_ease_next + 1
				
			end
			
			-- active mod eases
			for key, entry in pairs(mod_ease_active) do
				apply_ease(entry)
				if beat >= entry[1] + entry[2] then
					mod_ease_active[key] = nil
				end
				
			end
			
			-- mod funcs
			while mod_func_next <= mod_func_length do
				local entry = mod_func[mod_func_next]
				if beat < entry[1] then
					break
				end
				if entry[2] then
					mod_func_active[mod_func_next] = entry
				else
					entry[3](beat - entry[1], mod_values, mod_base)
				end
				mod_func[mod_func_next] = nil
				mod_func_next = mod_func_next + 1
			end
			
			-- active mod funcs
			for key, entry in pairs(mod_func_active) do
				if beat < entry[1] + entry[2] then
					entry[3](beat - entry[1], mod_values, mod_base)
				else
					mod_func_active[key] = nil
				end
			end
			
			-- spread P0's mods down to other players when necessary
			for pn = 1, MAX_PN do
				for mod, percent in pairs(mod_values[pn]) do
					local value = mod_values[0][mod]
					if value then
						mod_values[pn][mod] = percent + value
					end
				end
			end
			
			-- apply mods from mod_values
			for pn = 0, MAX_PN do
				local string_out = {pn == 0 and 'mod,clearall' or 'mod'}
				local n = 1
				for mod, percent in pairs(mod_values[pn]) do
					
					-- if mod is an exception
					if ease_vars[mod] then
						if type(ease_vars[mod]) == 'function' then
							local val = ease_vars[mod](percent, pn)
							if val then
								n = n + 1
								string_out[n] = val
							end
						end
					else
						-- otherwise apply as normal
						n = n + 1
						string_out[n] = '*9e9 ' .. percent .. ' ' .. mod
					end
				end
				if pn == 0 then
					-- all-player mods
					GAMESTATE:ApplyGameCommand(table.concat(string_out, ','))
				elseif n > 1 then
					-- player specific
					GAMESTATE:ApplyGameCommand(table.concat(string_out, ','), pn)
				end
			end
			
		end
		
	end
	
	-- export xero as a global
	_G.xero = xero
	
	-- runs at the end of init-time
	function xero.cleanup()
	
		-- remove init-time items
		xero.update = nil
		xero.ready = nil
		xero.name = nil
		
		-- clean up global
		_G.xero = old_xero
		
	end
	
end"
OnCommand = "propagate,1;queuecommand,Name;sleep,9e9"
>
	<children>
		
		<!-- Helper files -->
		<Layer File = "sort.xml" />
		<Layer File = "easing.xml" />
		
		<!-- Actor for running the Update loop without propagating to children -->
		<Layer
			Type = "Quad"
			NameCommand = "queuecommand,Ready"
			ReadyCommand = "%xero.ready"
			UpdateCommand = "%xero.update"
			InitCommand = "zoom,0;effectclock,music"
		/>
		
		<!-- Foreground actors for the modfile -->
		<Layer File = "lua/actors.xml" />
		
		<!-- Mod initialization -->
		<Layer
			File = "lua/mods.xml"
			NameCommand = "%xero.name.mods"
			OnCommand = "hidden,1"
		/>
		
		<!-- Doesn't get added to scene -->
		<Layer Condition = "xero.cleanup()" />
	</children>
</Layer>