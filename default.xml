<Layer Type = "ActorFrame" Condition = "(function() --[[

XeroOl's Galaxy Mod Loader

Documentation TODO




]]
	-- config
	local MAX_PN = 2
	local ENABLED = FUCK_EXE
	
	local old_xero = _G.xero
	
	-- global for xml setup and environment for Lua
	local xero = setmetatable({}, {
		__call = function(self, func)
			setfenv(func, self)
			return func
		end,
		__index = _G
	})
	
	do -- vars
		
		xero.scx = SCREEN_CENTER_X
		xero.scy = SCREEN_CENTER_Y
		xero.sw = SCREEN_WIDTH
		xero.sh = SCREEN_HEIGHT
		xero.srat = SCREEN_WIDTH / SCREEN_HEIGHT
		
	end
	
	do -- actor helpers
		
		-- table for holding named actors
		xero.actors = {}
		
		-- Use it to insert into xero.actors at init-time
		-- NameCommand = &quot;xero.name.<actor_name>&quot;
		xero.name = setmetatable({},{__index = function(self, name)
			return function(self)
				xero.actors[name] = self
			end
		end})
		
		-- aft function
		function xero.aft(self)
			self:SetWidth(DISPLAY:GetDisplayWidth())
			self:SetHeight(DISPLAY:GetDisplayHeight())
			self:EnableDepthBuffer(false)
			self:EnableAlphaBuffer(false)
			self:EnableFloat(false)
			self:EnablePreserveTexture(true)
			self:Create()
		end
		
		-- aft sprite function
		function xero.sprite(self)
			self:basezoomx((SCREEN_WIDTH/DISPLAY:GetDisplayWidth()))
			self:basezoomy(-1*(SCREEN_HEIGHT/DISPLAY:GetDisplayHeight()))
			self:x(SCREEN_CENTER_X)
			self:y(SCREEN_CENTER_Y)
		end
		
		-- full screen actor function
		function xero.image(self)
			self:scaletocover(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT)
		end
	end
	
	-- exceptions for how to apply mods
	local ease_vars = {}
	
	-- add new exceptions to ease_vars
	function xero.ease_var(mod, value)
		value = value or true
		ease_vars[mod] = value
		return xero.ease_var
	end
	
	-- ease table
	local mod_ease = {}
	local mod_ease_active = {}
	local mod_ease_length = 0
	local mod_ease_next = 1

	-- ease table insert
	function xero.ease(input)
		mod_ease_length = mod_ease_length + 1
		mod_ease[mod_ease_length] = input
		return xero.ease
	end
	
	-- func table
	local mod_func = {}
	local mod_func_active = {}
	local mod_func_length = 0
	local mod_func_next = 1
	
	-- func table insert
	function xero.func(input)
		
		if type(input[2]) == 'function' then
			input[2], input[3] = nil, input[2]
		end
		
		mod_func_length = mod_func_length + 1
		mod_func[mod_func_length] = input
		return xero.func
		
	end
	
	-- prepare mods
	function xero.ready(self)
		
		-- apply default mods
		xero.ease_var('xmod', function(percent) return '*9e9 ' .. percent .. 'x' end)
		xero.ease_var('cmod', function(percent) return '*9e9 c' .. percent end)
		
		local function hide(actor)
			if actor then
				actor:hidden(1)
			end
		end
		
		local top = SCREENMAN:GetTopScreen()
		
		-- create player table
		xero.plr = {}
		
		for pn = 1, MAX_PN do
			xero.plr[pn] = top:GetChild('PlayerP' .. pn)
		end
		
		-- plr 0 guaranted to exist for notedata
		xero.plr[0] = xero.plr[1] or xero.plr[2]
		
		-- hide extra stuff
		hide(top:GetChild('Overlay'))
		hide(top:GetChild('Underlay'))
		for pn = 1, 2 do
			hide(top:GetChild('ScoreP' .. pn))
			hide(top:GetChild('LifeP' .. pn))
		end
		
		-- load mods
		xero.actors.mods:playcommand'Mod'
		
		-- sort tables
		table.sort(mod_ease, function(a, b)
			return a[1] < b[1]
		end)
		
		table.sort(mod_func, function(a, b)
			return a[1] < b[1]
		end)
		
		-- start the update loop
		xero.actors.update:luaeffect('Update')
	end
	
	-- placeholder 0 for perfuncs
	local nil_as_0_metatable = {
		__index = function(self, key)
			return 0
		end
	}
	
	-- tables for base values (for accessing and iterating, respectively)
	local mod_base, mod_base_data = {}, {}
	
	-- set up base values
	for pn = 0, MAX_PN do
		local data = setmetatable({}, nil_as_0_metatable)
		mod_base_data[pn] = data
		mod_base[pn] = setmetatable({}, {
			__index = data,
			__newindex = function(self, key, value)
				if value == 0 then
					data[key] = nil
				else
					data[key] = value
				end
			end
		})
	end
	
	local old_time = 0
	
	-- update command
	function xero.update(self)
		local cur_time = GAMESTATE:GetSongTime()
		if cur_time ~= old_time then
			old_time = cur_time
			
			local beat = GAMESTATE:GetSongBeat()
			
			local mod_values = {}
			
			-- initialize mod_values to mod_base
			for pn = 0, MAX_PN do
				mod_values[pn] = setmetatable({}, nil_as_0_metatable)
				for mod, percent in pairs(mod_base_data[pn]) do
					mod_values[pn][mod] = percent
				end
			end
			
			-- mod eases
			while mod_ease_next <= mod_ease_length do
				
				-- quit if too early
				if beat < mod_ease[mod_ease_next][1] then
					break
				end
				
				-- move to active eases
				mod_ease_active[mod_ease_next] = mod_ease[mod_ease_next]
				mod_ease[mod_ease_next] = nil
				mod_ease_next = mod_ease_next + 1
				
			end
			
			-- active mod eases
			for key, entry in pairs(mod_ease_active) do
				local pn = entry.pn or 0
				
				-- done yet or still in progress?
				if beat < entry[1] + entry[2] then
				
					-- calculate current ease progress
					local ease = entry[3]((beat - entry[1]) / entry[2])
					
					-- for each mod
					local val = 5
					while entry[val] do
						
						-- write to values
						mod_values[pn][entry[val]] = mod_values[pn][entry[val]] + ease * entry[val - 1]
						
						val = val + 2
					end
					
				else
					
					-- calculate final value precisely
					local ease = entry[3](1)
					
					-- for each mod
					local val = 5
					while entry[val] do
						
						-- write back to base for permanent change
						mod_base[pn][entry[val]] = mod_base[pn][entry[val]] + ease * entry[val - 1]
						
						-- write to values
						mod_values[pn][entry[val]] = mod_values[pn][entry[val]] + ease * entry[val - 1]
						
						val = val + 2
					end
					
					-- delete from active when done
					mod_ease_active[key] = nil
					
				end
				
			end
			
			-- spread P0's mods down to other players when necessary
			for pn = 1, MAX_PN do
				for mod, percent in pairs(mod_values[pn]) do
					local value = mod_values[0][mod]
					if value then
						mod_values[pn][mod] = percent + value
					end
				end
			end
			
			-- mod funcs
			while mod_func_next <= mod_func_length do
				
				local entry = mod_func[mod_func_next]
				
				-- quit if too early
				if beat < entry[1] then
					break
				end
				
				-- check if one-time function
				if entry[2] then
					
					-- move to active funcs
					mod_func_active[mod_func_next] = mod_func[mod_func_next]
					
				else
					
					-- run
					entry[3](beat - entry[1], mod_values, mod_base)
					
				end
				
				-- clean up data
				mod_func[mod_func_next] = nil
				mod_func_next = mod_func_next + 1
				
			end
			
			-- active mod funcs
			for key, entry in pairs(mod_func_active) do
				
				-- if still in range
				if beat < entry[1] + entry[2] then
					
					-- run func
					entry[3](beat - entry[1], mod_values, mod_base)
					
				else
					
					-- remove
					mod_func_active[key] = nil
					
				end
				
			end
			
			-- apply mods from mod_values
			for pn = 0, MAX_PN do
				
				-- build string
				local string_out = {pn == 0 and 'mod,clearall' or 'mod'}
				local n = 2
				
				-- for each mod
				for mod, percent in pairs(mod_values[pn]) do
					
					-- if mod is an exception
					if ease_vars[mod] then
						
						-- apply if applicable
						if type(ease_vars[mod]) == 'function' then
							
							local val = ease_vars[mod](percent, mod)
							if val then
								
								-- add to string if applicable
								string_out[n] = val
								n = n + 1
								
							end
							
						end
						
					else
						
						-- otherwise apply as normal
						string_out[n] = '*9e9 ' .. percent .. ' ' .. mod
						n = n + 1
					end
					
				end
				
				if pn == 0 then
					
					-- all-player mods
					GAMESTATE:ApplyGameCommand(table.concat(string_out, ','))
					
				elseif n > 2 then
					
					-- player specific
					GAMESTATE:ApplyGameCommand(table.concat(string_out, ','), pn)
					
				end
				
			end
			
		end
		
	end
	
	-- export xero as a global
	_G.xero = xero
	
	-- runs at the end of init-time
	function xero.cleanup()
	
		-- remove init-time items
		xero.update = nil
		xero.ready = nil
		xero.name = nil
		
		-- clean up global
		_G.xero = old_xero
		
	end
	
	return ENABLED
	
end)()"
OnCommand = "queuecommand,Name;queuecommand,Type;queuecommand,Ready;sleep,9e9"
ReadyCommand = "%xero.ready"
>
	<children>
		
		<Layer File = "easing.xml" />
			
		<!-- Empty ActorFrame for running the Update loop without propagating to children -->
		<Layer
			Type = "ActorFrame"
			NameCommand = "%xero.name.update"
			UpdateCommand = "%xero.update"
		/>
		
		<!-- Foreground actors for the modfile -->
		<Layer File = "lua/actors.xml" />
		
		<!-- Mod initialization -->
		<Layer
			File = "lua/mods.xml"
			NameCommand = "%xero.name.mods"
			OnCommand = "hidden,1"
		/>
		
		<!-- Doesn't get added to scene -->
		<Layer Condition = "xero.cleanup()" />
	</children>
</Layer>