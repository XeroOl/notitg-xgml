<CODE Type="Quad" ModCommand="%xero(function(self)
	
	---------------------------------------------------------------------------------------
	----------------------DON'T TOUCH IT KIDDO---------------------------------------------
	---------------------------------------------------------------------------------------
	
	function xero.perframe(beat, endBeat)
		local cur = GAMESTATE:GetSongBeat()
		return cur >= beat and cur < endBeat
	end
	
	
	--mod_insert has no parallel in XGML
	function xero.mod_insert()
		error('mod_insert doesn\'t work in XGML')
	end
	
	--mod2_insert has no parallel in XML
	function xero.mod2_insert()
		error('mod2_insert doesn\'t work in XGML')
	end
	
	function xero.mod_ease(beat, len, str1, str2, mod, t, ease, pn, sus)
		sus = sus or 0
		t = t or xero.
		if t == 'end' then
			len = len - beat
		end
		
		xero.ease_to
		{beat, 0, instant, str1, mod, pn = pn, mode = 'len'}
		{beat, len, ease, str2, mod, pn = pn, mode = 'len'}
		{beat + len + sus, 0, instant, 0, mod, pn = pn, mode = 'len'}
	end
	
	function xero.mod_perframe(start_beat,end_beat,f)
		xero.func{start_beat, end_beat, f, mode = 'end'}
	end
	
	function xero.mod_message(beat,msg,p)
		p = p or 1
		func{beat, function(beat)
			if (p == true) or p < beat then
				msg()
			end
		end}
	end
	
	local blacklist_cache = {}
	function xero.mod_blacklist(t,n)
		-- load from cache
		local cache = blacklist_cache[t]
		
		-- build cache
		if not cache then
			cache = {}
			
			for i = 1, table.getn(t) do
				cache[t[i]] = true
			end
			
			blacklist_cache[t] = cache
		end
		
		-- read from cache
		return cache[n]
	end
	
	--how can I make simple m0d?
	--this will instantly turn a mod on to max and then quickly turn it off with the specified parameters
	--it's a simple mod
	
	function xero.simple_m0d(beat, strength, mult, mod, pn)
		stength = strength or 400
		mult = mult or 1
		mod = mod or 'drunk'
		local alive = mult * math.abs(strength) * 0.01
		xero.ease{beat, alive, tooth, strength, mod, pn = pn, mode = 'len'}
	end
	
	function xero.simple_m0d2(beat,strength,mult,mod,pn)
		if not strength then strength = 400 end
		if not mult then mult = 1 end
		if not mod then mod = 'drunk' end
		
		local alive = math.max(10*mult*math.abs(strength)/100,0.25)
		
		table.insert(mods,{beat,0.3,'*'..math.abs(strength/10)..' '..strength..' '..mod,'len',pn});
		table.insert(mods,{beat+.3,alive,'*'..((1/mult)*math.abs(strength)/100)..' no '..mod,'len',pn});
	end
	
	function simple_m0d3(beat,strength,duration,bpm,mod,pn)
		if not strength then strength = 400 end
		if not duration then duration = 1 end
		if not bpm then bpm = 120 end
		if not mod then mod = 'drunk' end
		
		local alive = duration * (60/bpm)
		local str = (1/(duration * 60/bpm)) * (math.abs(strength)/100)
		
		table.insert(mods,{beat-duration,duration,'*'..str..' '..strength..' '..mod,'len',pn});
		table.insert(mods,{beat,duration*1.1,'*'..str..' no '..mod,'len',pn});
	end
	
	--alternates a mod back and forth before resetting to 0
	--beat,num,div,amt,speed,mod,pn
	function mod_wiggle(beat,num,div,amt,speed,mod,pn,first)
		if not speed then speed = 1 end
		local fluct = 1
		for i=0,(num-1) do
			b = beat+(i/div)
			local m = 1
			if i==0 and not first then m = 0.5 end
			table.insert(mods,{b,1,'*'..math.abs(m*speed*amt/10)..' '..(amt*fluct)..' '..mod..'','len',pn});
			fluct = fluct*-1;
		end
		table.insert(mods,{beat+(num/div),1,'*'..math.abs(amt*speed/20)..' no '..mod..'','len',pn});
	end
	
	--like wiggle, but springier
	--beat,strength,num,mod,pn
	function mod_spring(beat,strength,num,mod,pn)
		local fluct = 1;
		for i=0,num do
			if i==0 then mult = 0.5 else mult = 1 end
			local amt = (num-i)/num
			local b = beat+(0.05*i)
			
			table.insert(mods,{b,0.3,'*'..math.max(math.abs(1000*strength*mult*amt),1)..' '..(strength*amt*fluct)..' '..mod,'len',pn});
			
			fluct = fluct*-1;
		end
	end
	
	function mod_springt(beat,strength,dur,mod,pn)
		local fluct = 1;
		dur = math.max(dur,0.02)
		for i=0,dur-.01,0.02 do
			local mult = 1;
			local amt = (dur-i)/dur
			local b = beat+i
			
			table.insert(mods2,{b,0.02,'*100000 '..(strength*amt*fluct)..' '..mod,'len',pn});
			
			fluct = fluct*-1;
		end
		table.insert(mods2,{beat+dur,0.1,'*100000 no '..mod,'len',pn});
	end
	
	function mod_springt2(beat,strength,dur,mod,pn)
		local fluct = 1;
		for i=0,dur-.01,0.02 do
			local b = beat+i
			
			table.insert(mods2,{b,0.02,'*100000 '..(strength*fluct)..' '..mod,'len',pn});
			
			fluct = fluct*-1;
		end
		table.insert(mods2,{beat+dur,0.1,'*100000 no '..mod,'len',pn});
	end
	
	--beat,strength,num,period,mod,pn
	function mod_spring_adjustable(beat,strength,num,period,mod,pn, first)
		local fluct = 1;
		for i=0,num do
			if i==0 then mult = 0.5 else mult = 1 end
			local amt = (num-i)/num
			local b = beat+(period*0.5*i)
			
			local m = 1
			if i==0 and not first then m = 0.5 end
			
			table.insert(mods,{b,0.3,'*'..math.max(m*math.abs((0.2/period)*strength*mult*amt),1)..' '..(strength*amt*fluct)..' '..mod,'len',pn});
			
			fluct = fluct*-1;
		end
	end
	
	--turns on beat for the beat specified, at the desired strength	
	function mod_beat(beat,strength,pn)
		if not strength then strength = 1000 end;
		table.insert(mods,{beat-.5,1,'*10000 '..strength..' beat','len',pn});
		table.insert(mods,{beat+.5,0.25,'*10000 no beat','len',pn});
	end
	
	function switcheroo_reset()
		switcheroo_flip = {0,0,0};
		switcheroo_invert = {0,0,0};
	end
	
	switcheroo_flip = {0,0,0};
	switcheroo_invert = {0,0,0};
	
	switcheroo_width = 1;
		
	
	
	function switcheroo_add(beat,which,speed,len,pn)

		if not speed then speed = 1000000 end
		
		local mpn = 3
		if pn then mpn = pn end
		
		local w = {0,0}
		
		if type(which) == 'string' then w = switcheroos[which] end
		if type(which) == 'table' then w = which end
		
		if w then
			local targf = (switcheroos[which][1]*switcheroo_width) + ( 50 - switcheroo_width*50 )
			local targi = (switcheroos[which][2]*switcheroo_width)
			local sw_modlist = ''
			if switcheroo_flip[mpn] ~= targf then
				sw_modlist = sw_modlist..'*'..(0.01*speed*math.abs(targf-switcheroo_flip[mpn]))..' '..(targf)..' flip,'
			else
				sw_modlist = sw_modlist..'*1 '..(targf)..' flip,'
			end
			if switcheroo_invert[mpn] ~= targi then
				sw_modlist = sw_modlist..'*'..(0.01*speed*math.abs(targi-switcheroo_invert[mpn]))..' '..(targi)..' invert'
			else
				sw_modlist = sw_modlist..'*1 '..(targi)..' invert'
			end
			table.insert(mods,{beat,len,sw_modlist,'len',pn});
			
			--Trace('SPEED: '..(0.01*speed*math.abs(targf-switcheroo_flip)));
			Trace(sw_modlist);
			
			if mpn == 3 then
				for apn=1,3 do
					switcheroo_flip[apn] = targf;
					switcheroo_invert[apn] = targi;
				end
			else
				switcheroo_flip[mpn] = targf;
				switcheroo_invert[mpn] = targi;
			end
		
		end
		
	end
	
	--portable version of the effect from sugarkill X
	function mod_sugarkiller(beat,duration,speed,minstealth,maxstealth,pn)
		if not minstealth then minstealth = 50 end
		if not maxstealth then maxstealth = 85 end
		if not speed then speed = 1 end
		local dur = duration
		if not dur then dur = 1 end
		dur = dur*speed;
		for i=0,math.max(dur-1,0) do
			table.insert(mods,{beat+(i*0.5),.25/speed,'*10000 Invert, *10000 no flip, *10000 '..maxstealth..'% Stealth','len',pn})
			table.insert(mods,{beat+(i*0.5)+.25/speed,.25/speed,'*10000 Flip, *10000 no invert, *10000 '..maxstealth..'% Stealth','len',pn})
			table.insert(mods,{beat+(i*0.5)+.50/speed,.25/speed,'*10000 Flip,*10000 -100% Invert,*10000 '..maxstealth..'% Stealth','len',pn})
			if i == math.max(dur-1,0) then
				table.insert(mods,{beat+(i*0.5)+.75/speed,.25/speed,'*10000 No Flip,*10000 No Invert,*10000 no Stealth','len',pn})
			else
				table.insert(mods,{beat+(i*0.5)+.75/speed,.25/speed,'*10000 No Flip,*10000 No Invert,*10000 '..minstealth..'% Stealth','len',pn})
			end
		end
	end
	
	-- hey alright
	function modulo(a, b)
		return a - math.floor(a/b)*b;
	end
	
	-- counterrotation function by BrotherMojo
	-- returns confusion(x/y/z)offsets to counteract the given rotations
	function reverseRotation(angleX, angleY, angleZ)
		local DEG_TO_RAD = math.pi / 180
		angleX, angleY, angleZ = DEG_TO_RAD * angleX, DEG_TO_RAD * angleY, DEG_TO_RAD * angleZ
		local sinX = math.sin(angleX);
		local cosX = math.cos(angleX);
		local sinY = math.sin(angleY);
		local cosY = math.cos(angleY);
		local sinZ = math.sin(angleZ);
		local cosZ = math.cos(angleZ);
		return 100 * math.atan2(-cosX*sinY*sinZ-sinX*cosZ,cosX*cosY), 100 * math.asin(-cosX*sinY*cosZ+sinX*sinZ), 100 * math.atan2(-sinX*sinY*cosZ-cosX*sinZ,cosY*cosZ)
	end
	
	--dumb random function
	function randomXD(t)
		if t == 0 then return 0.5 else
		return modulo(math.sin(t * 3229.3) * 43758.5453, 1) end
	end
	
	function mod_bounce(beat,length,start,apex,mod,ease,pn)
		mod_ease(beat, (length/2), start, apex, tostring(mod), 'len', _G['out'..ease],pn)
		mod_ease(beat+(length/2), (length/2), apex, start, tostring(mod), 'len', _G['in'..ease],pn,0.2)
	end
	
	function func_bounce(beat,length,start,apex,func,ease)
		func_ease(beat,(length/2),start,apex,func,'len',_G['out'..tostring(ease)])
		func_ease(beat+(length/2),(length/2),apex,start,func,'len',_G['in'..tostring(ease)],nil,0.2)
	end

	--stolen from hal thank you very cool
	function ease_wiggle(beatS,beatE,amt,inc,str,ease,len,pn)
		local rotStart = 0
		local prevRot = amt
		local curRot = -amt
		local measure = tostring(len)
		local asdf = 0
		if measure == 'end' then
			asdf = beatE
		elseif measure == 'len' then
			asdf = (beatS+beatE)
		end
		for i = beatS,asdf,inc do
			if i == beatS then
				rotStart = 0
			else
				rotStart = prevRot
			end
			if i == asdf then
				rotEnd = 0
			else
				rotEnd = curRot
			end
				mod_ease(i-inc, inc, rotStart, rotEnd, str, 'len', ease, pn)
				prevRot = prevRot *-1
				curRot = curRot *-1
		end
	end

	function ease_wiggleAbs(beatS,beatE,amt,inc,str,ease,len,pn)
		local rotStart = 0
		local prevRot = 0
		local curRot = amt
		local counter = 1
		local measure = tostring(len)
		local asdf = 0
		if measure == 'end' then
			asdf = beatE
		elseif measure == 'len' then
			asdf = (beatS+beatE)
		end
		for i = beatS,asdf-inc,inc do
			if counter == -1 then
				preRot,curRot = amt, 0
			elseif counter == 1 then
				preRot,curRot = 0, amt
			end
			mod_ease(i, inc, preRot, curRot, str, 'len', ease, pn)
			counter = counter*-1
		end
	end
	
	function mod_drivendrop(beat,length,step,speedmod,pn)
		for i = beat,((beat+length)-1)-step,step do
			local cutoff = (step-0.05)
			mod_insert(i, cutoff, '*'..speedmod..' 10000 centered2','len',pn)
			mod_insert(i+cutoff, 0.05, '*-1 no centered2','len',pn)
		end
	end
---------------------------------------------------------------------------------------
----------------------END DON'T TOUCH IT KIDDO-----------------------------------------
---------------------------------------------------------------------------------------

end)"/>